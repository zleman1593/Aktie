use :node;

var fs = ::Meteor.npmRequire('fs');
var os = ::Meteor.npmRequire('os');

var SERVER_DELAY = 500;//ms

var backupTask = new ScheduledTask('at 12:01 am', fn () {
    backupPartnerToSelf();
  console.log("Backup was run.");
});

var heartbeatCheck = new ScheduledTask('every 30 sec', fn () {

if PartnerIndex.status().connected {
  console.log("Partner is healthy!");
} else{
      console.log("Partner is DOWN!");
        console.log("Spawning replacement!");
        console.log("Restoring replacement!");
}
});

var PartnerIndex;

::Meteor.startup(fn() {
        //Init backup schedule
        backupTask.start();
        //Report own Address
        ::getOwnIPAndPort();
        //Connect to partner and maintin heartbeat
        var partnerAddress = "http://IndexNode.meteor.com";
         PartnerIndex = ::DDP.connect(host);

        var status = ::Async.runSync(fn(done) {
            setTimeout(fn(){ done(null,server.status());},SERVER_DELAY);//enough time to allow connection
        });

        if status.result.connected {
             console.log("Connected to partner");
        } else{
             console.log("Not Connected to partner");
        }
});


::Meteor.methods({
    findFile: fn(fileName) {
         this.unblock;
        console.log("Finding the File Part Locations for: \(fileName.fileName)" );

        var file = ::Files.findOne({
            "fileName": fileName.fileName
        });

        console.log(JSON.stringify(file));
        //Grab file part from one of the peers that has it.
        var chunks = file.chunks.map(fn(currentValue, index, array) {
            return currentValue[Math.floor((Math.random() * currentValue.length))];
        });
        chunks = chunks.map(fn(currentValue, index, array) {
            return {
                "chunkNumber": index,
                "chunk": currentValue
            };
        });

        console.log(JSON.stringify(chunks));

        return {
            "fileName": fileName.fileName,
            "chunks": chunks
        };
    },

        getReplacementChunk: fn(info) {
         this.unblock;
        console.log("Finding the New File Part Location for: \(info.fileName): Chunk \(info.chunkNumber)" );

        var file = ::Files.findOne({
            "fileName": info.fileName
        });

        //Grab file part from one of the peers that has it.
        var chunkLocations = file.chunks[info.chunkNumber];


        var chunk = { "chunkNumber": info.chunkNumber,
                 "chunk": chunkLocations[Math.floor((Math.random() * chunkLocations.length))]
            };
   

        console.log(JSON.stringify(chunk));

        return {
            "fileName": info.fileName,
            "chunk": chunk
        };
    },


    registerFile: fn(fileName, numberOfParts, hostNameWithPort,updateFromIndexNode) {
         this.unblock;
         // if !updateFromIndexNode {
         //     ::IndexNode.call('registerFile', fileName, numberOfParts.result, hostNameWithPort,true);        }
         // }

        var file = ::Files.findOne({
            "fileName": fileName
        });

        if !file? {
            //If file has not already been registered in the Index node
            var fileToInsert = {
                "fileName": fileName,
                "chunks": []
            };
             console.log("registering new File with \(numberOfParts) parts");

            for var i = 0; i < numberOfParts; i++ {
                fileToInsert.chunks.push([hostNameWithPort]);
            }

            ::Files.insert(fileToInsert);
        } else {
            //else add  to the file meta data that a new client has this file avalible

                for var i = 0; i <  file.chunks.length; i++ {
                    //Don't allow duplicate entries
                    if   !::_.contains(file.chunks[i],hostNameWithPort) {
                    file.chunks[i].push(hostNameWithPort);
                     }
                }
                ::Files.update(file._id,file);
        }
    },

     registerFileChunk: fn(fileName, chunkNumber, hostNameWithPort,updateFromIndexNode) {
        console.log("fileName: \(fileName). chunkNumber: \(chunkNumber)");
        //this.unblock;
        var file = ::Files.findOne({
            "fileName": fileName
        });
        if file? {
        file.chunks[chunkNumber].push(hostNameWithPort);     
         ::Files.update(file._id,file);
        } else{
              throw new::Meteor.Error(500, 'Error 500: Not registered', 'A file by this name has not been registered.');
        }
    },

});


 fn getOwnIPAndPort() {
    var interfaces = os.networkInterfaces();
    var addresses = [];
    for  k in interfaces {
        for  k2 in interfaces[k] {
            var address = interfaces[k][k2];
            if address.family == 'IPv4' && !address.internal {
                addresses.push(address.address);

            }
        }
    }

    console.log("\(addresses[0]):\(process.env.PORT)");
    return "\(addresses[0]):\(process.env.PORT)";

  } 

fn backupPartnerToSelf(){
    //Remove old Backup
    BackupForPartner.remove({});
    //Create new backup
    PartnerIndex.subscribe("allFiles");

    AllFilesToBeBackedUp = new Mongo.Collection('toBackup', {connection: PartnerIndex});

    var cursor = AllFilesToBeBackedUp.find();

     cursor.forEach(fn(doc){
         ::BackupForPartner.insert(doc);
    });

   
}


