use :node;

var fs = ::Meteor.npmRequire('fs');
var os = ::Meteor.npmRequire('os');

var SERVER_DELAY = 500;//ms

var backupTask = new ::ScheduledTask('at 12:01 am', fn () {
    ::backupPartnerToSelf();
  console.log("Backup was run.");
});

var heartbeatCheck = new ::ScheduledTask('every 30 sec', fn () {

if ::PartnerIndex.status().connected {
  console.log("Partner is healthy!");
} else{
      console.log("Partner is DOWN!");
        console.log("Spawning replacement!");
        console.log("Restoring replacement!");
}
});

var PartnerIndex;

::Meteor.startup(fn() {
        //Init backup schedule
        backupTask.start();
        //Report own Address
        ::getOwnIPAndPort();
        //Connect to partner and maintin heartbeat
        var partnerAddress = "http://IndexNode.meteor.com";
         ::PartnerIndex = ::DDP.connect(partnerAddress);

        var status = ::Async.runSync(fn(done) {
            setTimeout(fn(){ done(null,::PartnerIndex.status());},SERVER_DELAY);//enough time to allow connection
        });

        if status.result.connected {
             console.log("Connected to partner");
        } else{
             console.log("Not Connected to partner");
        }
});


::Meteor.methods({
    findFile: fn(fileName) {
         this.unblock;
        console.log("Finding the File Part Locations for: \(fileName.fileName)" );

        var file = ::Files.findOne({
            "fileName": fileName.fileName
        });
        if !file?{
                 throw new ::Meteor.Error(240, "Error 320: Could Not find file", "A file by this name has not been registered.");
            }

        console.log(JSON.stringify(file));

        var dictOfPeersUsedSoFar = {};

        //Grab file part from one of the peers that has it. Even distribution of chunks to avalible peers.
        var chunks = file.chunks.map(fn(currentValue, index, array) {

                var bestPeerToUse;//
                var bestPeerToUseIndex;
                var bestPeerToUseCount = Number.MAX_VALUE;

                 for var i = 0; i < currentValue.length; i++ {

                    var machineName = "\(currentValue[i])";
                    var machineCount = dictOfPeersUsedSoFar[machineName];
                   
                       if !machineCount? {
                            //If peer hasn't been used for this transfer at all yet, use it.
                            dictOfPeersUsedSoFar[machineName] = 1;
                            return currentValue[i];
                       } else if machineCount < bestPeerToUseCount{
                            //If this peer is being used less than  other peers looked at so far.
                            bestPeerToUse =  machineName;
                            bestPeerToUseCount = machineCount;
                            bestPeerToUseIndex = i;
                       }
                 }
            
            //update the dictionary with the peer that was used for this chunk
            dictOfPeersUsedSoFar[bestPeerToUse] += 1;
            //Use optimal peer for this chunk
            return currentValue[bestPeerToUseIndex];
        });


        chunks = chunks.map(fn(currentValue, index, array) {
            return {
                "chunkNumber": index,
                "chunk": currentValue
            };
        });

        console.log(JSON.stringify(chunks));

        return {
            "fileName": fileName.fileName,
            "chunks": chunks
        };
    },

        getReplacementChunk: fn(info) {
         this.unblock;
        console.log("Finding the New File Part Location for: \(info.fileName): Chunk \(info.chunkNumber)" );

        var file = ::Files.findOne({
            "fileName": info.fileName
        });

        //Grab file part from one of the peers that has it.
        var chunkLocations = file.chunks[info.chunkNumber];


        var chunk = { "chunkNumber": info.chunkNumber,
                 "chunk": chunkLocations[Math.floor((Math.random() * chunkLocations.length))]
            };
   

        console.log(JSON.stringify(chunk));

        return {
            "fileName": info.fileName,
            "chunk": chunk
        };
    },


    registerFile: fn(fileName, numberOfParts, hostNameWithPort,updateFromIndexNode) {
         this.unblock;
         // if !updateFromIndexNode {
         //     ::IndexNode.call('registerFile', fileName, numberOfParts.result, hostNameWithPort,true);        }
         // }

        var file = ::Files.findOne({
            "fileName": fileName
        });

        if !file? {
            //If file has not already been registered in the Index node
            var fileToInsert = {
                "fileName": fileName,
                "chunks": []
            };
             console.log("registering new File with \(numberOfParts) parts");

            for var i = 0; i < numberOfParts; i++ {
                fileToInsert.chunks.push([hostNameWithPort]);
            }

            ::Files.insert(fileToInsert);
        } else {
            //else add  to the file meta data that a new client has this file avalible

                for var i = 0; i <  file.chunks.length; i++ {
                    //Don't allow duplicate entries
                    if   !::_.contains(file.chunks[i],hostNameWithPort) {
                    file.chunks[i].push(hostNameWithPort);

                     } else{
                        throw new::Meteor.Error(240, 'Error 240: Already registered', 'A file by this name has not been registered.');
                          return;
                     }
                }
                ::Files.update(file._id,file);
        }
    },

     registerFileChunk: fn(fileName, chunkNumber, hostNameWithPort,updateFromIndexNode) {
        console.log("fileName: \(fileName). chunkNumber: \(chunkNumber)");
        //this.unblock;
        var file = ::Files.findOne({
            "fileName": fileName
        });
        if file? {
        file.chunks[chunkNumber].push(hostNameWithPort);     
         ::Files.update(file._id,file);
        } else{
              throw new::Meteor.Error(240, 'Error 240: Already registered', 'A file by this name has not been registered.');
        }
    },

});


 fn getOwnIPAndPort() {
    var interfaces = os.networkInterfaces();
    var addresses = [];
    for  k in interfaces {
        for  k2 in interfaces[k] {
            var address = interfaces[k][k2];
            if address.family == 'IPv4' && !address.internal {
                addresses.push(address.address);

            }
        }
    }

    console.log("\(addresses[0]):\(process.env.PORT)");
    return "\(addresses[0]):\(process.env.PORT)";

  } 

fn backupPartnerToSelf(){
    //Remove old Backup
    ::BackupForPartner.remove({});
    //Create new backup
    ::PartnerIndex.subscribe("allFiles");

    var AllFilesToBeBackedUp = new ::Mongo.Collection('toBackup', {connection: ::PartnerIndex});

    var cursor = AllFilesToBeBackedUp.find();

     cursor.forEach(fn(doc){
         ::BackupForPartner.insert(doc);
    });
 }


fn restoreSelfFromPartner(){
   
    ::PartnerIndex.subscribe("allBackupFiles");

    var AllBackedUpFiles = new ::Mongo.Collection('theBackup', {connection: ::PartnerIndex});

    var cursor = AllBackedUpFiles.find();

     cursor.forEach(fn(doc){
         ::Files.insert(doc);
    });
    //PartnerIndex.unsubscribe("allBackupFiles");
   
}


